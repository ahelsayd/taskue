<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>taskue.controller API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>taskue.controller</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pickle
import sys
import time

from typing import Iterator
from loguru import logger
from redis import Redis
from redis.client import Pipeline
from redis.lock import Lock
from taskue.task import _Task
from taskue.workflow import _Workflow

class Keys:
    def __init__(self, namespace: str = &#34;default&#34;):
        &#34;&#34;&#34;Helper class to generate redis keys

        Keyword Arguments:
            namespace {str} -- namespace name (default: {&#34;default&#34;})
        &#34;&#34;&#34;
        self.prefix = &#34;taskue&#34;
        self.namespace = namespace

    @property
    def namespaces(self):
        return f&#34;{self.prefix}:{self.namespace}:namespaces&#34;

    @property
    def runner(self):
        return f&#34;{self.prefix}:{self.namespace}:runner:%s&#34;

    @property
    def heartbeat(self):
        return f&#34;{self.prefix}:{self.namespace}:heartbeat:%s&#34;

    @property
    def monitoring_job(self):
        return f&#34;{self.prefix}:{self.namespace}:monitoring&#34;

    @property
    def workflow(self):
        return f&#34;{self.prefix}:{self.namespace}:workflow:%s&#34;

    @property
    def workflows(self):
        return f&#34;{self.prefix}:{self.namespace}:workflows&#34;

    @property
    def task(self):
        return f&#34;{self.prefix}:{self.namespace}:task:%s&#34;

    @property
    def tasks(self):
        return f&#34;{self.prefix}:{self.namespace}:tasks&#34;

    @property
    def new_workflows(self):
        return f&#34;{self.prefix}:{self.namespace}:new:workflows&#34;

    @property
    def task_queue(self):
        return f&#34;{self.prefix}:{self.namespace}:queued:%s&#34;

    @property
    def events(self):
        return f&#34;{self.prefix}:{self.namespace}:events&#34;

    def get_namespace_keys(self, namespace):
        return f&#34;{self.prefix}:{namespace}:*&#34;


class RedisController:
    def __init__(self, connection: Redis, namespace: str):
        &#34;&#34;&#34;Redis controller class

        Arguments:
            connection {Redis} -- redis connection
            namespace {str} -- namespace name
        &#34;&#34;&#34;
        self._connection = connection
        self._namespace = namespace
        self.keys = Keys(namespace=namespace)

    def decode_bytes(self, ddict: dict) -&gt; dict:
        result = dict()
        for key, value in ddict.items():
            result[key.decode()] = value.decode()
        return result

    def ping(self) -&gt; bool:
        return self._connection.ping()

    def pipeline(self) -&gt; Pipeline:
        return self._connection.pipeline()

    def lock(self, name: str, sleep: float = 0.01) -&gt; Lock:
        return self._connection.lock(name, sleep=sleep)

    def blpop(self, queues: list, timeout: int = None) -&gt; tuple:
        queue = data = None
        response = self._connection.blpop(queues, timeout=timeout)
        if response:
            queue = response[0].decode()
            data = response[1].decode()
        return queue, data

    def namespaces_list(self) -&gt; Iterator[dict]:
        namespaces = self._connection.hscan_iter(self.keys.namespaces)
        for item in namespaces:
            namespace, timestamp = item
            yield dict(name=namespace.decode(), timestamp=int(timestamp.decode()))

    def namespace_delete(self, namespace: str):
        pipeline = self._connection.pipeline()
        pipeline.hdel(self.keys.namespaces, namespace)
        namespace_keys = self.keys.get_namespace_keys(namespace)

        if namespace_keys:
            pipeline.delete(*namespace_keys)

        pipeline.execute()

    def runners_list(self) -&gt; Iterator[dict]:
        keys = self._connection.keys(self.keys.runner % &#34;*&#34;)
        for key in keys:
            yield self.decode_bytes(self._connection.hgetall(key))

    def runner_get(self, runner_name: str) -&gt; dict:
        runner = self._connection.hgetall(self.keys.runner % runner_name)
        if runner:
            return self.decode_bytes(runner)

    def runner_register(self, name: str, namespace: str, status: str, queues: list, timeout: int):
        data = {&#34;name&#34;: name, &#34;namespace&#34;: namespace, &#34;status&#34;: status, &#34;timeout&#34;: timeout, &#34;queues&#34;: &#34;,&#34;.join(queues)}
        self._connection.hmset(self.keys.runner % name, data)

    def is_runner_healthy(self, name: str) -&gt; bool:
        return self._connection.exists(self.keys.heartbeat % name)

    def acquire_monitoring_task(self, name: str, timeout: int = 30) -&gt; bool:
        return self._connection.set(self.keys.monitoring_job, name, ex=timeout, nx=True)

    def runner_status_get(self, name: str) -&gt; str:
        return self._connection.hget(self.keys.runner % name, &#34;status&#34;,).decode()

    def runner_update(self, name: str, pipeline: Pipeline = None, **kwargs):
        connection = pipeline if pipeline is not None else self._connection
        return connection.hmset(self.keys.runner % name, kwargs)

    def runner_save(self, name: str, ddict: dict, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.hmset(self.keys.runner % name, ddict)

    def heartbeat_send(self, name: str, timeout: int, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.set(self.keys.heartbeat % name, &#34;&#34;, ex=timeout)

    def workflow_get(self, workflow_uid: str, pipeline: Pipeline = None) -&gt; _Workflow:
        connection = pipeline if pipeline is not None else self._connection
        blob = connection.get(self.keys.workflow % workflow_uid)
        if blob:
            return pickle.loads(blob)

    def workflow_save(self, workflow, queue=False, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.set(self.keys.workflow % workflow.uid, pickle.dumps(workflow))
        if queue:
            connection.zadd(
                self.keys.workflows, {self.keys.workflow % workflow.uid: workflow.created_at},
            )
            connection.rpush(self.keys.new_workflows, workflow.uid)

    def workflows_list(self, start: int, end: int, pipeline: Pipeline = None) -&gt; Iterator[_Workflow]:
        connection = pipeline if pipeline is not None else self._connection
        keys = connection.zrange(self.keys.workflows, start, end, desc=True)
        if keys:
            results = connection.mget(keys)
            for blob in results:
                if blob:
                    yield pickle.loads(blob)

    def workflows_count(self) -&gt; int:
        return self._connection.zcard(self.keys.workflows)

    def workflow_delete(self, workflow_uid: str, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.delete(self.keys.workflow % workflow_uid)
        connection.zrem(self.keys.workflows, workflow_uid)

    def task_get(self, task_uid: str) -&gt; _Task:
        blob = self._connection.get(self.keys.task % task_uid)
        if blob:
            return pickle.loads(blob)

    def task_save(self, task, notify: bool = False, queue: bool = False, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.set(self.keys.task % task.uid, pickle.dumps(task))

        if notify:
            connection.rpush(self.keys.events, task.uid)

        if queue:
            connection.zadd(
                self.keys.tasks, {self.keys.task % task.uid: task.created_at},
            )
            connection.rpush(self.keys.task_queue % (task.tag or &#34;default&#34;), task.uid)

    def tasks_list(self, start: int, end: int, pipeline: Pipeline = None) -&gt; Iterator[_Task]:
        connection = pipeline if pipeline is not None else self._connection
        keys = connection.zrange(self.keys.tasks, start, end, desc=True)
        if keys:
            results = connection.mget(keys)
            for blob in results:
                if blob:
                    yield pickle.loads(blob)

    def tasks_count(self) -&gt; int:
        return self._connection.zcard(self.keys.tasks)

    def task_delete(self, task_uid: str, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.delete(self.keys.task % task_uid)
        connection.zrem(self.keys.tasks, task_uid)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="taskue.controller.Keys"><code class="flex name class">
<span>class <span class="ident">Keys</span></span>
<span>(</span><span>namespace: str = 'default')</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class to generate redis keys</p>
<p>Keyword Arguments:
namespace {str} &ndash; namespace name (default: {"default"})</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Keys:
    def __init__(self, namespace: str = &#34;default&#34;):
        &#34;&#34;&#34;Helper class to generate redis keys

        Keyword Arguments:
            namespace {str} -- namespace name (default: {&#34;default&#34;})
        &#34;&#34;&#34;
        self.prefix = &#34;taskue&#34;
        self.namespace = namespace

    @property
    def namespaces(self):
        return f&#34;{self.prefix}:{self.namespace}:namespaces&#34;

    @property
    def runner(self):
        return f&#34;{self.prefix}:{self.namespace}:runner:%s&#34;

    @property
    def heartbeat(self):
        return f&#34;{self.prefix}:{self.namespace}:heartbeat:%s&#34;

    @property
    def monitoring_job(self):
        return f&#34;{self.prefix}:{self.namespace}:monitoring&#34;

    @property
    def workflow(self):
        return f&#34;{self.prefix}:{self.namespace}:workflow:%s&#34;

    @property
    def workflows(self):
        return f&#34;{self.prefix}:{self.namespace}:workflows&#34;

    @property
    def task(self):
        return f&#34;{self.prefix}:{self.namespace}:task:%s&#34;

    @property
    def tasks(self):
        return f&#34;{self.prefix}:{self.namespace}:tasks&#34;

    @property
    def new_workflows(self):
        return f&#34;{self.prefix}:{self.namespace}:new:workflows&#34;

    @property
    def task_queue(self):
        return f&#34;{self.prefix}:{self.namespace}:queued:%s&#34;

    @property
    def events(self):
        return f&#34;{self.prefix}:{self.namespace}:events&#34;

    def get_namespace_keys(self, namespace):
        return f&#34;{self.prefix}:{namespace}:*&#34;</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="taskue.controller.Keys.events"><code class="name">var <span class="ident">events</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def events(self):
    return f&#34;{self.prefix}:{self.namespace}:events&#34;</code></pre>
</details>
</dd>
<dt id="taskue.controller.Keys.heartbeat"><code class="name">var <span class="ident">heartbeat</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def heartbeat(self):
    return f&#34;{self.prefix}:{self.namespace}:heartbeat:%s&#34;</code></pre>
</details>
</dd>
<dt id="taskue.controller.Keys.monitoring_job"><code class="name">var <span class="ident">monitoring_job</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def monitoring_job(self):
    return f&#34;{self.prefix}:{self.namespace}:monitoring&#34;</code></pre>
</details>
</dd>
<dt id="taskue.controller.Keys.namespaces"><code class="name">var <span class="ident">namespaces</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def namespaces(self):
    return f&#34;{self.prefix}:{self.namespace}:namespaces&#34;</code></pre>
</details>
</dd>
<dt id="taskue.controller.Keys.new_workflows"><code class="name">var <span class="ident">new_workflows</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def new_workflows(self):
    return f&#34;{self.prefix}:{self.namespace}:new:workflows&#34;</code></pre>
</details>
</dd>
<dt id="taskue.controller.Keys.runner"><code class="name">var <span class="ident">runner</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def runner(self):
    return f&#34;{self.prefix}:{self.namespace}:runner:%s&#34;</code></pre>
</details>
</dd>
<dt id="taskue.controller.Keys.task"><code class="name">var <span class="ident">task</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def task(self):
    return f&#34;{self.prefix}:{self.namespace}:task:%s&#34;</code></pre>
</details>
</dd>
<dt id="taskue.controller.Keys.task_queue"><code class="name">var <span class="ident">task_queue</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def task_queue(self):
    return f&#34;{self.prefix}:{self.namespace}:queued:%s&#34;</code></pre>
</details>
</dd>
<dt id="taskue.controller.Keys.tasks"><code class="name">var <span class="ident">tasks</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def tasks(self):
    return f&#34;{self.prefix}:{self.namespace}:tasks&#34;</code></pre>
</details>
</dd>
<dt id="taskue.controller.Keys.workflow"><code class="name">var <span class="ident">workflow</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def workflow(self):
    return f&#34;{self.prefix}:{self.namespace}:workflow:%s&#34;</code></pre>
</details>
</dd>
<dt id="taskue.controller.Keys.workflows"><code class="name">var <span class="ident">workflows</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def workflows(self):
    return f&#34;{self.prefix}:{self.namespace}:workflows&#34;</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="taskue.controller.Keys.get_namespace_keys"><code class="name flex">
<span>def <span class="ident">get_namespace_keys</span></span>(<span>self, namespace)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_namespace_keys(self, namespace):
    return f&#34;{self.prefix}:{namespace}:*&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="taskue.controller.RedisController"><code class="flex name class">
<span>class <span class="ident">RedisController</span></span>
<span>(</span><span>connection: redis.client.Redis, namespace: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Redis controller class</p>
<h2 id="arguments">Arguments</h2>
<p>connection {Redis} &ndash; redis connection
namespace {str} &ndash; namespace name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RedisController:
    def __init__(self, connection: Redis, namespace: str):
        &#34;&#34;&#34;Redis controller class

        Arguments:
            connection {Redis} -- redis connection
            namespace {str} -- namespace name
        &#34;&#34;&#34;
        self._connection = connection
        self._namespace = namespace
        self.keys = Keys(namespace=namespace)

    def decode_bytes(self, ddict: dict) -&gt; dict:
        result = dict()
        for key, value in ddict.items():
            result[key.decode()] = value.decode()
        return result

    def ping(self) -&gt; bool:
        return self._connection.ping()

    def pipeline(self) -&gt; Pipeline:
        return self._connection.pipeline()

    def lock(self, name: str, sleep: float = 0.01) -&gt; Lock:
        return self._connection.lock(name, sleep=sleep)

    def blpop(self, queues: list, timeout: int = None) -&gt; tuple:
        queue = data = None
        response = self._connection.blpop(queues, timeout=timeout)
        if response:
            queue = response[0].decode()
            data = response[1].decode()
        return queue, data

    def namespaces_list(self) -&gt; Iterator[dict]:
        namespaces = self._connection.hscan_iter(self.keys.namespaces)
        for item in namespaces:
            namespace, timestamp = item
            yield dict(name=namespace.decode(), timestamp=int(timestamp.decode()))

    def namespace_delete(self, namespace: str):
        pipeline = self._connection.pipeline()
        pipeline.hdel(self.keys.namespaces, namespace)
        namespace_keys = self.keys.get_namespace_keys(namespace)

        if namespace_keys:
            pipeline.delete(*namespace_keys)

        pipeline.execute()

    def runners_list(self) -&gt; Iterator[dict]:
        keys = self._connection.keys(self.keys.runner % &#34;*&#34;)
        for key in keys:
            yield self.decode_bytes(self._connection.hgetall(key))

    def runner_get(self, runner_name: str) -&gt; dict:
        runner = self._connection.hgetall(self.keys.runner % runner_name)
        if runner:
            return self.decode_bytes(runner)

    def runner_register(self, name: str, namespace: str, status: str, queues: list, timeout: int):
        data = {&#34;name&#34;: name, &#34;namespace&#34;: namespace, &#34;status&#34;: status, &#34;timeout&#34;: timeout, &#34;queues&#34;: &#34;,&#34;.join(queues)}
        self._connection.hmset(self.keys.runner % name, data)

    def is_runner_healthy(self, name: str) -&gt; bool:
        return self._connection.exists(self.keys.heartbeat % name)

    def acquire_monitoring_task(self, name: str, timeout: int = 30) -&gt; bool:
        return self._connection.set(self.keys.monitoring_job, name, ex=timeout, nx=True)

    def runner_status_get(self, name: str) -&gt; str:
        return self._connection.hget(self.keys.runner % name, &#34;status&#34;,).decode()

    def runner_update(self, name: str, pipeline: Pipeline = None, **kwargs):
        connection = pipeline if pipeline is not None else self._connection
        return connection.hmset(self.keys.runner % name, kwargs)

    def runner_save(self, name: str, ddict: dict, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.hmset(self.keys.runner % name, ddict)

    def heartbeat_send(self, name: str, timeout: int, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.set(self.keys.heartbeat % name, &#34;&#34;, ex=timeout)

    def workflow_get(self, workflow_uid: str, pipeline: Pipeline = None) -&gt; _Workflow:
        connection = pipeline if pipeline is not None else self._connection
        blob = connection.get(self.keys.workflow % workflow_uid)
        if blob:
            return pickle.loads(blob)

    def workflow_save(self, workflow, queue=False, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.set(self.keys.workflow % workflow.uid, pickle.dumps(workflow))
        if queue:
            connection.zadd(
                self.keys.workflows, {self.keys.workflow % workflow.uid: workflow.created_at},
            )
            connection.rpush(self.keys.new_workflows, workflow.uid)

    def workflows_list(self, start: int, end: int, pipeline: Pipeline = None) -&gt; Iterator[_Workflow]:
        connection = pipeline if pipeline is not None else self._connection
        keys = connection.zrange(self.keys.workflows, start, end, desc=True)
        if keys:
            results = connection.mget(keys)
            for blob in results:
                if blob:
                    yield pickle.loads(blob)

    def workflows_count(self) -&gt; int:
        return self._connection.zcard(self.keys.workflows)

    def workflow_delete(self, workflow_uid: str, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.delete(self.keys.workflow % workflow_uid)
        connection.zrem(self.keys.workflows, workflow_uid)

    def task_get(self, task_uid: str) -&gt; _Task:
        blob = self._connection.get(self.keys.task % task_uid)
        if blob:
            return pickle.loads(blob)

    def task_save(self, task, notify: bool = False, queue: bool = False, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.set(self.keys.task % task.uid, pickle.dumps(task))

        if notify:
            connection.rpush(self.keys.events, task.uid)

        if queue:
            connection.zadd(
                self.keys.tasks, {self.keys.task % task.uid: task.created_at},
            )
            connection.rpush(self.keys.task_queue % (task.tag or &#34;default&#34;), task.uid)

    def tasks_list(self, start: int, end: int, pipeline: Pipeline = None) -&gt; Iterator[_Task]:
        connection = pipeline if pipeline is not None else self._connection
        keys = connection.zrange(self.keys.tasks, start, end, desc=True)
        if keys:
            results = connection.mget(keys)
            for blob in results:
                if blob:
                    yield pickle.loads(blob)

    def tasks_count(self) -&gt; int:
        return self._connection.zcard(self.keys.tasks)

    def task_delete(self, task_uid: str, pipeline: Pipeline = None):
        connection = pipeline if pipeline is not None else self._connection
        connection.delete(self.keys.task % task_uid)
        connection.zrem(self.keys.tasks, task_uid)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="taskue.controller.RedisController.acquire_monitoring_task"><code class="name flex">
<span>def <span class="ident">acquire_monitoring_task</span></span>(<span>self, name: str, timeout: int = 30) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def acquire_monitoring_task(self, name: str, timeout: int = 30) -&gt; bool:
    return self._connection.set(self.keys.monitoring_job, name, ex=timeout, nx=True)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.blpop"><code class="name flex">
<span>def <span class="ident">blpop</span></span>(<span>self, queues: list, timeout: int = None) -> tuple</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blpop(self, queues: list, timeout: int = None) -&gt; tuple:
    queue = data = None
    response = self._connection.blpop(queues, timeout=timeout)
    if response:
        queue = response[0].decode()
        data = response[1].decode()
    return queue, data</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.decode_bytes"><code class="name flex">
<span>def <span class="ident">decode_bytes</span></span>(<span>self, ddict: dict) -> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decode_bytes(self, ddict: dict) -&gt; dict:
    result = dict()
    for key, value in ddict.items():
        result[key.decode()] = value.decode()
    return result</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.heartbeat_send"><code class="name flex">
<span>def <span class="ident">heartbeat_send</span></span>(<span>self, name: str, timeout: int, pipeline: redis.client.Pipeline = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heartbeat_send(self, name: str, timeout: int, pipeline: Pipeline = None):
    connection = pipeline if pipeline is not None else self._connection
    connection.set(self.keys.heartbeat % name, &#34;&#34;, ex=timeout)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.is_runner_healthy"><code class="name flex">
<span>def <span class="ident">is_runner_healthy</span></span>(<span>self, name: str) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_runner_healthy(self, name: str) -&gt; bool:
    return self._connection.exists(self.keys.heartbeat % name)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.lock"><code class="name flex">
<span>def <span class="ident">lock</span></span>(<span>self, name: str, sleep: float = 0.01) -> redis.lock.Lock</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lock(self, name: str, sleep: float = 0.01) -&gt; Lock:
    return self._connection.lock(name, sleep=sleep)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.namespace_delete"><code class="name flex">
<span>def <span class="ident">namespace_delete</span></span>(<span>self, namespace: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def namespace_delete(self, namespace: str):
    pipeline = self._connection.pipeline()
    pipeline.hdel(self.keys.namespaces, namespace)
    namespace_keys = self.keys.get_namespace_keys(namespace)

    if namespace_keys:
        pipeline.delete(*namespace_keys)

    pipeline.execute()</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.namespaces_list"><code class="name flex">
<span>def <span class="ident">namespaces_list</span></span>(<span>self) -> Iterator[dict]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def namespaces_list(self) -&gt; Iterator[dict]:
    namespaces = self._connection.hscan_iter(self.keys.namespaces)
    for item in namespaces:
        namespace, timestamp = item
        yield dict(name=namespace.decode(), timestamp=int(timestamp.decode()))</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.ping"><code class="name flex">
<span>def <span class="ident">ping</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ping(self) -&gt; bool:
    return self._connection.ping()</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.pipeline"><code class="name flex">
<span>def <span class="ident">pipeline</span></span>(<span>self) -> redis.client.Pipeline</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipeline(self) -&gt; Pipeline:
    return self._connection.pipeline()</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.runner_get"><code class="name flex">
<span>def <span class="ident">runner_get</span></span>(<span>self, runner_name: str) -> dict</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runner_get(self, runner_name: str) -&gt; dict:
    runner = self._connection.hgetall(self.keys.runner % runner_name)
    if runner:
        return self.decode_bytes(runner)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.runner_register"><code class="name flex">
<span>def <span class="ident">runner_register</span></span>(<span>self, name: str, namespace: str, status: str, queues: list, timeout: int)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runner_register(self, name: str, namespace: str, status: str, queues: list, timeout: int):
    data = {&#34;name&#34;: name, &#34;namespace&#34;: namespace, &#34;status&#34;: status, &#34;timeout&#34;: timeout, &#34;queues&#34;: &#34;,&#34;.join(queues)}
    self._connection.hmset(self.keys.runner % name, data)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.runner_save"><code class="name flex">
<span>def <span class="ident">runner_save</span></span>(<span>self, name: str, ddict: dict, pipeline: redis.client.Pipeline = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runner_save(self, name: str, ddict: dict, pipeline: Pipeline = None):
    connection = pipeline if pipeline is not None else self._connection
    connection.hmset(self.keys.runner % name, ddict)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.runner_status_get"><code class="name flex">
<span>def <span class="ident">runner_status_get</span></span>(<span>self, name: str) -> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runner_status_get(self, name: str) -&gt; str:
    return self._connection.hget(self.keys.runner % name, &#34;status&#34;,).decode()</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.runner_update"><code class="name flex">
<span>def <span class="ident">runner_update</span></span>(<span>self, name: str, pipeline: redis.client.Pipeline = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runner_update(self, name: str, pipeline: Pipeline = None, **kwargs):
    connection = pipeline if pipeline is not None else self._connection
    return connection.hmset(self.keys.runner % name, kwargs)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.runners_list"><code class="name flex">
<span>def <span class="ident">runners_list</span></span>(<span>self) -> Iterator[dict]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runners_list(self) -&gt; Iterator[dict]:
    keys = self._connection.keys(self.keys.runner % &#34;*&#34;)
    for key in keys:
        yield self.decode_bytes(self._connection.hgetall(key))</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.task_delete"><code class="name flex">
<span>def <span class="ident">task_delete</span></span>(<span>self, task_uid: str, pipeline: redis.client.Pipeline = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def task_delete(self, task_uid: str, pipeline: Pipeline = None):
    connection = pipeline if pipeline is not None else self._connection
    connection.delete(self.keys.task % task_uid)
    connection.zrem(self.keys.tasks, task_uid)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.task_get"><code class="name flex">
<span>def <span class="ident">task_get</span></span>(<span>self, task_uid: str) -> taskue.task._Task</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def task_get(self, task_uid: str) -&gt; _Task:
    blob = self._connection.get(self.keys.task % task_uid)
    if blob:
        return pickle.loads(blob)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.task_save"><code class="name flex">
<span>def <span class="ident">task_save</span></span>(<span>self, task, notify: bool = False, queue: bool = False, pipeline: redis.client.Pipeline = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def task_save(self, task, notify: bool = False, queue: bool = False, pipeline: Pipeline = None):
    connection = pipeline if pipeline is not None else self._connection
    connection.set(self.keys.task % task.uid, pickle.dumps(task))

    if notify:
        connection.rpush(self.keys.events, task.uid)

    if queue:
        connection.zadd(
            self.keys.tasks, {self.keys.task % task.uid: task.created_at},
        )
        connection.rpush(self.keys.task_queue % (task.tag or &#34;default&#34;), task.uid)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.tasks_count"><code class="name flex">
<span>def <span class="ident">tasks_count</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tasks_count(self) -&gt; int:
    return self._connection.zcard(self.keys.tasks)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.tasks_list"><code class="name flex">
<span>def <span class="ident">tasks_list</span></span>(<span>self, start: int, end: int, pipeline: redis.client.Pipeline = None) -> Iterator[taskue.task._Task]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tasks_list(self, start: int, end: int, pipeline: Pipeline = None) -&gt; Iterator[_Task]:
    connection = pipeline if pipeline is not None else self._connection
    keys = connection.zrange(self.keys.tasks, start, end, desc=True)
    if keys:
        results = connection.mget(keys)
        for blob in results:
            if blob:
                yield pickle.loads(blob)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.workflow_delete"><code class="name flex">
<span>def <span class="ident">workflow_delete</span></span>(<span>self, workflow_uid: str, pipeline: redis.client.Pipeline = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def workflow_delete(self, workflow_uid: str, pipeline: Pipeline = None):
    connection = pipeline if pipeline is not None else self._connection
    connection.delete(self.keys.workflow % workflow_uid)
    connection.zrem(self.keys.workflows, workflow_uid)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.workflow_get"><code class="name flex">
<span>def <span class="ident">workflow_get</span></span>(<span>self, workflow_uid: str, pipeline: redis.client.Pipeline = None) -> taskue.workflow._Workflow</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def workflow_get(self, workflow_uid: str, pipeline: Pipeline = None) -&gt; _Workflow:
    connection = pipeline if pipeline is not None else self._connection
    blob = connection.get(self.keys.workflow % workflow_uid)
    if blob:
        return pickle.loads(blob)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.workflow_save"><code class="name flex">
<span>def <span class="ident">workflow_save</span></span>(<span>self, workflow, queue=False, pipeline: redis.client.Pipeline = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def workflow_save(self, workflow, queue=False, pipeline: Pipeline = None):
    connection = pipeline if pipeline is not None else self._connection
    connection.set(self.keys.workflow % workflow.uid, pickle.dumps(workflow))
    if queue:
        connection.zadd(
            self.keys.workflows, {self.keys.workflow % workflow.uid: workflow.created_at},
        )
        connection.rpush(self.keys.new_workflows, workflow.uid)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.workflows_count"><code class="name flex">
<span>def <span class="ident">workflows_count</span></span>(<span>self) -> int</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def workflows_count(self) -&gt; int:
    return self._connection.zcard(self.keys.workflows)</code></pre>
</details>
</dd>
<dt id="taskue.controller.RedisController.workflows_list"><code class="name flex">
<span>def <span class="ident">workflows_list</span></span>(<span>self, start: int, end: int, pipeline: redis.client.Pipeline = None) -> Iterator[taskue.workflow._Workflow]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def workflows_list(self, start: int, end: int, pipeline: Pipeline = None) -&gt; Iterator[_Workflow]:
    connection = pipeline if pipeline is not None else self._connection
    keys = connection.zrange(self.keys.workflows, start, end, desc=True)
    if keys:
        results = connection.mget(keys)
        for blob in results:
            if blob:
                yield pickle.loads(blob)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="taskue" href="index.html">taskue</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="taskue.controller.Keys" href="#taskue.controller.Keys">Keys</a></code></h4>
<ul class="two-column">
<li><code><a title="taskue.controller.Keys.events" href="#taskue.controller.Keys.events">events</a></code></li>
<li><code><a title="taskue.controller.Keys.get_namespace_keys" href="#taskue.controller.Keys.get_namespace_keys">get_namespace_keys</a></code></li>
<li><code><a title="taskue.controller.Keys.heartbeat" href="#taskue.controller.Keys.heartbeat">heartbeat</a></code></li>
<li><code><a title="taskue.controller.Keys.monitoring_job" href="#taskue.controller.Keys.monitoring_job">monitoring_job</a></code></li>
<li><code><a title="taskue.controller.Keys.namespaces" href="#taskue.controller.Keys.namespaces">namespaces</a></code></li>
<li><code><a title="taskue.controller.Keys.new_workflows" href="#taskue.controller.Keys.new_workflows">new_workflows</a></code></li>
<li><code><a title="taskue.controller.Keys.runner" href="#taskue.controller.Keys.runner">runner</a></code></li>
<li><code><a title="taskue.controller.Keys.task" href="#taskue.controller.Keys.task">task</a></code></li>
<li><code><a title="taskue.controller.Keys.task_queue" href="#taskue.controller.Keys.task_queue">task_queue</a></code></li>
<li><code><a title="taskue.controller.Keys.tasks" href="#taskue.controller.Keys.tasks">tasks</a></code></li>
<li><code><a title="taskue.controller.Keys.workflow" href="#taskue.controller.Keys.workflow">workflow</a></code></li>
<li><code><a title="taskue.controller.Keys.workflows" href="#taskue.controller.Keys.workflows">workflows</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="taskue.controller.RedisController" href="#taskue.controller.RedisController">RedisController</a></code></h4>
<ul class="">
<li><code><a title="taskue.controller.RedisController.acquire_monitoring_task" href="#taskue.controller.RedisController.acquire_monitoring_task">acquire_monitoring_task</a></code></li>
<li><code><a title="taskue.controller.RedisController.blpop" href="#taskue.controller.RedisController.blpop">blpop</a></code></li>
<li><code><a title="taskue.controller.RedisController.decode_bytes" href="#taskue.controller.RedisController.decode_bytes">decode_bytes</a></code></li>
<li><code><a title="taskue.controller.RedisController.heartbeat_send" href="#taskue.controller.RedisController.heartbeat_send">heartbeat_send</a></code></li>
<li><code><a title="taskue.controller.RedisController.is_runner_healthy" href="#taskue.controller.RedisController.is_runner_healthy">is_runner_healthy</a></code></li>
<li><code><a title="taskue.controller.RedisController.lock" href="#taskue.controller.RedisController.lock">lock</a></code></li>
<li><code><a title="taskue.controller.RedisController.namespace_delete" href="#taskue.controller.RedisController.namespace_delete">namespace_delete</a></code></li>
<li><code><a title="taskue.controller.RedisController.namespaces_list" href="#taskue.controller.RedisController.namespaces_list">namespaces_list</a></code></li>
<li><code><a title="taskue.controller.RedisController.ping" href="#taskue.controller.RedisController.ping">ping</a></code></li>
<li><code><a title="taskue.controller.RedisController.pipeline" href="#taskue.controller.RedisController.pipeline">pipeline</a></code></li>
<li><code><a title="taskue.controller.RedisController.runner_get" href="#taskue.controller.RedisController.runner_get">runner_get</a></code></li>
<li><code><a title="taskue.controller.RedisController.runner_register" href="#taskue.controller.RedisController.runner_register">runner_register</a></code></li>
<li><code><a title="taskue.controller.RedisController.runner_save" href="#taskue.controller.RedisController.runner_save">runner_save</a></code></li>
<li><code><a title="taskue.controller.RedisController.runner_status_get" href="#taskue.controller.RedisController.runner_status_get">runner_status_get</a></code></li>
<li><code><a title="taskue.controller.RedisController.runner_update" href="#taskue.controller.RedisController.runner_update">runner_update</a></code></li>
<li><code><a title="taskue.controller.RedisController.runners_list" href="#taskue.controller.RedisController.runners_list">runners_list</a></code></li>
<li><code><a title="taskue.controller.RedisController.task_delete" href="#taskue.controller.RedisController.task_delete">task_delete</a></code></li>
<li><code><a title="taskue.controller.RedisController.task_get" href="#taskue.controller.RedisController.task_get">task_get</a></code></li>
<li><code><a title="taskue.controller.RedisController.task_save" href="#taskue.controller.RedisController.task_save">task_save</a></code></li>
<li><code><a title="taskue.controller.RedisController.tasks_count" href="#taskue.controller.RedisController.tasks_count">tasks_count</a></code></li>
<li><code><a title="taskue.controller.RedisController.tasks_list" href="#taskue.controller.RedisController.tasks_list">tasks_list</a></code></li>
<li><code><a title="taskue.controller.RedisController.workflow_delete" href="#taskue.controller.RedisController.workflow_delete">workflow_delete</a></code></li>
<li><code><a title="taskue.controller.RedisController.workflow_get" href="#taskue.controller.RedisController.workflow_get">workflow_get</a></code></li>
<li><code><a title="taskue.controller.RedisController.workflow_save" href="#taskue.controller.RedisController.workflow_save">workflow_save</a></code></li>
<li><code><a title="taskue.controller.RedisController.workflows_count" href="#taskue.controller.RedisController.workflows_count">workflows_count</a></code></li>
<li><code><a title="taskue.controller.RedisController.workflows_list" href="#taskue.controller.RedisController.workflows_list">workflows_list</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>